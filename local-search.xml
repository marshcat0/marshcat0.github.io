<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>lodash-debounce</title>
    <link href="/2020/12/18/lodash-debounce/"/>
    <url>/2020/12/18/lodash-debounce/</url>
    
    <content type="html"><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>如图所示，lodash debounce函数接受的参数：<img src="params.png" alt="lodash参数"></p><h2 id="Lodash源码"><a href="#Lodash源码" class="headerlink" title="Lodash源码"></a>Lodash源码</h2><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">func, wait, options</span>) </span>&#123;  <span class="hljs-keyword">let</span> lastArgs,    lastThis,    maxWait,    result,    timerId,    lastCallTime  <span class="hljs-keyword">let</span> lastInvokeTime = <span class="hljs-number">0</span>  <span class="hljs-keyword">let</span> leading = <span class="hljs-literal">false</span>  <span class="hljs-keyword">let</span> maxing = <span class="hljs-literal">false</span>  <span class="hljs-keyword">let</span> trailing = <span class="hljs-literal">true</span>  <span class="hljs-comment">// Bypass `requestAnimationFrame` by explicitly setting `wait=0`.</span>  <span class="hljs-keyword">const</span> useRAF = (!wait &amp;&amp; wait !== <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">typeof</span> root.requestAnimationFrame === <span class="hljs-string">&#x27;function&#x27;</span>)  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> func !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;Expected a function&#x27;</span>)  &#125;  wait = +wait || <span class="hljs-number">0</span>  <span class="hljs-keyword">if</span> (isObject(options)) &#123;    leading = !!options.leading    maxing = <span class="hljs-string">&#x27;maxWait&#x27;</span> <span class="hljs-keyword">in</span> options    maxWait = maxing ? <span class="hljs-built_in">Math</span>.max(+options.maxWait || <span class="hljs-number">0</span>, wait) : maxWait    trailing = <span class="hljs-string">&#x27;trailing&#x27;</span> <span class="hljs-keyword">in</span> options ? !!options.trailing : trailing  &#125;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">invokeFunc</span>(<span class="hljs-params">time</span>) </span>&#123;    <span class="hljs-keyword">const</span> args = lastArgs    <span class="hljs-keyword">const</span> thisArg = lastThis    lastArgs = lastThis = <span class="hljs-literal">undefined</span>    lastInvokeTime = time    result = func.apply(thisArg, args)    <span class="hljs-keyword">return</span> result  &#125;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">startTimer</span>(<span class="hljs-params">pendingFunc, wait</span>) </span>&#123;    <span class="hljs-keyword">if</span> (useRAF) &#123;      root.cancelAnimationFrame(timerId)      <span class="hljs-keyword">return</span> root.requestAnimationFrame(pendingFunc)    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">setTimeout</span>(pendingFunc, wait)  &#125;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cancelTimer</span>(<span class="hljs-params">id</span>) </span>&#123;    <span class="hljs-keyword">if</span> (useRAF) &#123;      <span class="hljs-keyword">return</span> root.cancelAnimationFrame(id)    &#125;    <span class="hljs-built_in">clearTimeout</span>(id)  &#125;  <span class="hljs-comment">// 一个新的wait周期的开始</span>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">leadingEdge</span>(<span class="hljs-params">time</span>) </span>&#123;    <span class="hljs-comment">// Reset any `maxWait` timer.</span>    lastInvokeTime = time    <span class="hljs-comment">// Start the timer for the trailing edge.</span>    timerId = startTimer(timerExpired, wait)    <span class="hljs-comment">// Invoke the leading edge.</span>    <span class="hljs-keyword">return</span> leading ? invokeFunc(time) : result  &#125;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">remainingWait</span>(<span class="hljs-params">time</span>) </span>&#123;    <span class="hljs-keyword">const</span> timeSinceLastCall = time - lastCallTime    <span class="hljs-keyword">const</span> timeSinceLastInvoke = time - lastInvokeTime    <span class="hljs-keyword">const</span> timeWaiting = wait - timeSinceLastCall    <span class="hljs-keyword">return</span> maxing      ? <span class="hljs-built_in">Math</span>.min(timeWaiting, maxWait - timeSinceLastInvoke)      : timeWaiting  &#125;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shouldInvoke</span>(<span class="hljs-params">time</span>) </span>&#123;    <span class="hljs-keyword">const</span> timeSinceLastCall = time - lastCallTime    <span class="hljs-keyword">const</span> timeSinceLastInvoke = time - lastInvokeTime    <span class="hljs-comment">// Either this is the first call, activity has stopped and we&#x27;re at the</span>    <span class="hljs-comment">// trailing edge, the system time has gone backwards and we&#x27;re treating</span>    <span class="hljs-comment">// it as the trailing edge, or we&#x27;ve hit the `maxWait` limit.</span>    <span class="hljs-keyword">return</span> (lastCallTime === <span class="hljs-literal">undefined</span> || (timeSinceLastCall &gt;= wait) ||      (timeSinceLastCall &lt; <span class="hljs-number">0</span>) || (maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait))  &#125;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timerExpired</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">const</span> time = <span class="hljs-built_in">Date</span>.now()    <span class="hljs-keyword">if</span> (shouldInvoke(time)) &#123;      <span class="hljs-keyword">return</span> trailingEdge(time)    &#125;    <span class="hljs-comment">// Restart the timer.</span>    <span class="hljs-comment">// 现在还不到invoke的时间，因此设置定时器，等到可以执行后</span>    timerId = startTimer(timerExpired, remainingWait(time))  &#125;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">trailingEdge</span>(<span class="hljs-params">time</span>) </span>&#123;    timerId = <span class="hljs-literal">undefined</span>    <span class="hljs-comment">// Only invoke if we have `lastArgs` which means `func` has been</span>    <span class="hljs-comment">// debounced at least once.</span>    <span class="hljs-comment">// 个人理解，避免当leading和trailing都为true时，call了一次，invoke了两次</span>    <span class="hljs-keyword">if</span> (trailing &amp;&amp; lastArgs) &#123;      <span class="hljs-keyword">return</span> invokeFunc(time)    &#125;    lastArgs = lastThis = <span class="hljs-literal">undefined</span>    <span class="hljs-keyword">return</span> result  &#125;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cancel</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">if</span> (timerId !== <span class="hljs-literal">undefined</span>) &#123;      cancelTimer(timerId)    &#125;    lastInvokeTime = <span class="hljs-number">0</span>    lastArgs = lastCallTime = lastThis = timerId = <span class="hljs-literal">undefined</span>  &#125;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flush</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> timerId === <span class="hljs-literal">undefined</span> ? result : trailingEdge(<span class="hljs-built_in">Date</span>.now())  &#125;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pending</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> timerId !== <span class="hljs-literal">undefined</span>  &#125;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounced</span>(<span class="hljs-params">...args</span>) </span>&#123;    <span class="hljs-keyword">const</span> time = <span class="hljs-built_in">Date</span>.now()    <span class="hljs-keyword">const</span> isInvoking = shouldInvoke(time)    lastArgs = args    lastThis = <span class="hljs-built_in">this</span>    lastCallTime = time    <span class="hljs-keyword">if</span> (isInvoking) &#123;      <span class="hljs-comment">// 关于timerId</span>      <span class="hljs-comment">// 对于debounce，在一个wait周期内，如果调用了debounce后的函数，则重置wait周期，wait周期内没有再调用debounce后的函数，则执行函数</span>      <span class="hljs-comment">// 因此需要在wait周期末端，即trailingEdge，判断是否需要执行函数</span>      <span class="hljs-comment">// 在trailingEdge中，会将timerId设为undefined，因此timerId === undefined意味着此次调用debounce后的函数，是一个wait周期的开始</span>      <span class="hljs-comment">// 因此需要调用leadingEdge</span>      <span class="hljs-keyword">if</span> (timerId === <span class="hljs-literal">undefined</span>) &#123;        <span class="hljs-keyword">return</span> leadingEdge(lastCallTime)      &#125;      <span class="hljs-comment">// isInvoking 为true的四个条件，在timeId !== undefined时，</span>      <span class="hljs-comment">// lastCallTime !== undefined</span>      <span class="hljs-comment">// timeSinceLastCall &lt; wait</span>      <span class="hljs-comment">// 所以在maxing为truthy的情况下</span>      <span class="hljs-comment">// 可知 timeSinceLastInvoke &gt;= maxWait</span>      <span class="hljs-keyword">if</span> (maxing) &#123;        <span class="hljs-comment">// 这句注释不知什么意思</span>        <span class="hljs-comment">// Handle invocations in a tight loop.</span>        timerId = startTimer(timerExpired, wait)        <span class="hljs-comment">// 距上次invoke超过了maxWait，因此立即调用</span>        <span class="hljs-comment">// 此处记得区分invoke与call</span>        <span class="hljs-comment">// call指的是调用debounce后的函数，即本函数</span>        <span class="hljs-comment">// invoke指的是调用传入debounce的函数，即args中作为传入参数的函数</span>        <span class="hljs-keyword">return</span> invokeFunc(lastCallTime)      &#125;    &#125;    <span class="hljs-comment">// timerId为undefined，说明上个周期结束，已调用trailingEdge</span>    <span class="hljs-comment">// 结合!isInvoking，说明距上个周期结束，不超过wait和maxWait</span>    <span class="hljs-keyword">if</span> (timerId === <span class="hljs-literal">undefined</span>) &#123;      timerId = startTimer(timerExpired, wait)    &#125;    <span class="hljs-comment">// 补充，如timerId不是undefined，则直接return之前的result</span>    <span class="hljs-comment">// 需要注意，此时lastCallTime已经被更新，因此，等timerId设置的定时器到期时，</span>    <span class="hljs-comment">// 执行timerExpired，在shouldInvoke中发现之前还有一次call，会根据remainingWait</span>    <span class="hljs-comment">// 来重新设置定时器，在这次call的trailingEdge执行。</span>    <span class="hljs-keyword">return</span> result  &#125;  debounced.cancel = cancel  debounced.flush = flush  debounced.pending = pending  <span class="hljs-keyword">return</span> debounced&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> debounce</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为macOS bigsur开启HiDpi</title>
    <link href="/2020/11/23/bigSur-hidpi/"/>
    <url>/2020/11/23/bigSur-hidpi/</url>
    
    <content type="html"><![CDATA[<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol><li><a href="https://sspai.com/post/57549">为 macOS 10.15 开启 HiDPI，让 2K 显示器更舒适</a></li><li><a href="https://comsysto.github.io/Display-Override-PropertyList-File-Parser-and-Generator-with-HiDPI-Support-For-Scaled-Resolutions/">SCALED RESOLUTIONS<br>for your MacBooks external Monitor</a></li><li><a href="https://apple.stackexchange.com/a/395509">Mount root as writable in Big Sur</a></li></ol><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文适合有一定基础的人～最好有一定的英语阅读能力&amp;基本的shell知识</p><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><p>先按参考文档1的步骤，进行到<code>复制 plist 配置文件到系统配置目录</code>这一步时，就走不通了，因为在Big Sur中，苹果对于权限要求更严格，要通过额外的一系列操作才能获取根目录的写入权限了（参看文档3）。</p><p>大概解释一下文档3的意思：</p><ol><li>在恢复模式终端运行<code>csrutil authenticated-root disable</code>(与文档1中<code>csrutil disable</code>方法类似)</li><li>重启回系统，终端运行<code>mount</code>，如图所示<img src="./mount.png" alt="mount"><br>则<code>DISK_PATH</code>为<code>/dev/disk1s1</code>（把最后的s+数字去掉）</li><li>随便创建一个挂载的目录，文中路径为<code>~/mount</code>，即为<code>MOUNT_PATH</code></li><li>运行<code>sudo mount -o nobrowse -t apfs DISK_PATH MOUNT_PATH</code>（用上文的变量替换）</li><li>现在就可以在<code>~/mount</code>下修改系统文件了，如：要修改<code>/temp/1.txt</code>的文件，则应修改<code>~/mount/temp/1.txt</code></li><li>修改完成之后，运行<code>sudo bless --folder MOUNT_PATH/System/Library/CoreServices --bootefi --create-snapshot</code>（注意替换路径）</li><li>重启，修改即生效。下面就可以愉快地打开rdm修改分辨率了～</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/11/23/hello-world/"/>
    <url>/2020/11/23/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
