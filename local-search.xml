<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>常用的算法</title>
    <link href="/2021/10/09/%E5%B8%B8%E7%94%A8%E7%9A%84%E7%AE%97%E6%B3%95/"/>
    <url>/2021/10/09/%E5%B8%B8%E7%94%A8%E7%9A%84%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><blockquote><p>鉴于网上搜出来的快排的代码乱七八糟的，自己还是整理一份。取自大学C语言教材严蔚敏版本。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> partition = <span class="hljs-function">(<span class="hljs-params">A, low, high</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> pivot = A[low]<br>  <span class="hljs-keyword">while</span>(low &lt; high) &#123;<br>    <span class="hljs-keyword">while</span>(low &lt; high &amp;&amp; A[high] &gt;= pivot) high--<br>    A[low] = A[high]<br>    <span class="hljs-keyword">while</span>(low &lt; high &amp;&amp; A[low] &lt;= pivot) low++<br>    A[high] = A[low]<br>  &#125;<br>  A[low] = pivot<br><br>  <span class="hljs-keyword">return</span> low<br>&#125;<br><span class="hljs-keyword">const</span> quickSort = <span class="hljs-function">(<span class="hljs-params">array, low, high</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (low &lt; high) &#123;<br>    <span class="hljs-keyword">const</span> pivotPos = partition(array, low, high)<br>    quickSort(array, low, pivotPos - <span class="hljs-number">1</span>)<br>    quickSort(array, pivotPos + <span class="hljs-number">1</span>, high)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Top-k"><a href="#Top-k" class="headerlink" title="Top k"></a>Top k</h3><blockquote><p>鉴于自己对<code>Top k</code>不熟练，记录一下。</p></blockquote><p><a href="%5Barray.md%5D(https://leetcode-cn.com/problems/kth-largest-element-in-an-array)"><code>Top k</code></a>可以用快排的思想来解决（也可用堆排）。大致代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> partition = <span class="hljs-function">(<span class="hljs-params">A, low, high</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> pivot = A[low]<br>  <span class="hljs-keyword">while</span>(low &lt; high) &#123;<br>    <span class="hljs-keyword">while</span>(low &lt; high &amp;&amp; A[high] &gt;= pivot) high--<br>    A[low] = A[high]<br>    <span class="hljs-keyword">while</span>(low &lt; high &amp;&amp; A[low] &lt;= pivot) low++<br>    A[high] = A[low]<br>  &#125;<br>  A[low] = pivot<br><br>  <span class="hljs-keyword">return</span> low<br>&#125;<br><span class="hljs-keyword">const</span> quickSearch = <span class="hljs-function">(<span class="hljs-params">A, i, j, k</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (i &lt;= j) &#123;  <span class="hljs-comment">// ***1***</span><br>    <span class="hljs-keyword">const</span> pivotIndex = partition(A, i, j)<br><br>    <span class="hljs-keyword">if</span> (pivotIndex === k) <span class="hljs-keyword">return</span> A[k] <span class="hljs-comment">// ***2***</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pivotIndex &lt; k) &#123;<br>      <span class="hljs-keyword">return</span> quickSearch(A, pivotIndex + <span class="hljs-number">1</span>, j, k)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> quickSearch(A, i, pivotIndex - <span class="hljs-number">1</span>, k)<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> findKthLargest = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, k</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> result = quickSearch(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>, nums.length - k)<br>  <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><p>可见大致思路与快排差不多，不过有两处需要注意：</p><ol><li><p>此处原来是<code>i &lt; j</code>，在这里改成了<code>i &lt;= j</code>，因为判断<code>pivotIndex === k</code>的逻辑在该<code>if</code>内部，若<code>i === j</code>时，跳过<code>if</code>，则会导致某些条件下不能返回正确值。如，对于输入<code>[1] 1</code>或<code>[2, 1], 2</code>，<code>i &lt; j</code>均会返回<code>undefined</code>。</p></li><li><p>对快排的思路做优化，因为在本算法中，<code>pivot</code>左边的元素均<code>&lt;=</code>自身，右边的元素均<code>&gt;=</code>自身，因此在寻找<code>Top k</code>时，仅递归包含<code>k</code>的那一部分即可。</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于new操作符</title>
    <link href="/2021/09/30/%E5%85%B3%E4%BA%8Enew%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <url>/2021/09/30/%E5%85%B3%E4%BA%8Enew%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<ol><li><p>当一个空函数用<code>new</code>执行时，它做了以下的操作：</p><ul><li>一个新的对象被创建并且赋值给了<code>this</code></li><li>运行函数体，这个函数通常修改<code>this</code>，向其中增加新的属性</li><li>返回<code>this</code>的值</li></ul><p> 如：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-comment">// this = &#123;&#125;;  (implicitly)</span><br><br>  <span class="hljs-comment">// add properties to this</span><br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-built_in">this</span>.isAdmin = <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// return this;  (implicitly)</span><br>&#125;<br></code></pre></td></tr></table></figure><p> 这样<code>let user = new User(&quot;Jack&quot;)</code>与以下的结果相同：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> user = &#123;<br>  name: <span class="hljs-string">&quot;Jack&quot;</span>,<br>  isAdmin: <span class="hljs-literal">false</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>注意箭头函数不能被<code>new</code>调用，因为<code>new</code>没有自己的<code>this</code></p></li><li><p><code>new.target</code>可以得知构造函数是否被<code>new</code>调用，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">new</span>.target) &#123; <span class="hljs-comment">// if you run me without new</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(name); <span class="hljs-comment">// ...I will add new for you</span><br>  &#125;<br><br>  <span class="hljs-built_in">this</span>.name = name;<br>&#125;<br><br><span class="hljs-keyword">let</span> john = User(<span class="hljs-string">&quot;John&quot;</span>); <span class="hljs-comment">// redirects call to new User</span><br>alert(john.name); <span class="hljs-comment">// John</span><br></code></pre></td></tr></table></figure></li><li><p>在构造函数中<code>return</code>值时的规则：</p><ul><li>若<code>return</code>一个对象，则返回该对象</li><li>若<code>return</code>一个基本数据类型，则忽略它（仍返回<code>this</code>）</li></ul><p> 如：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BigUser</span>(<span class="hljs-params"></span>) </span>&#123;<br><br>  <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&quot;John&quot;</span>;<br><br>  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Godzilla&quot;</span> &#125;;  <span class="hljs-comment">// &lt;-- returns this object</span><br>&#125;<br><br>alert( <span class="hljs-keyword">new</span> BigUser().name );  <span class="hljs-comment">// Godzilla, got that object</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SmallUser</span>(<span class="hljs-params"></span>) </span>&#123;<br><br>  <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&quot;John&quot;</span>;<br><br>  <span class="hljs-keyword">return</span>; <span class="hljs-comment">// &lt;-- returns this</span><br>&#125;<br><br>alert( <span class="hljs-keyword">new</span> SmallUser().name );  <span class="hljs-comment">// John</span><br></code></pre></td></tr></table></figure></li><li><p>构造函数无参数时，可省略括号（不推荐），如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> User; <span class="hljs-comment">// &lt;-- no  parentheses</span><br><span class="hljs-comment">// same as</span><br><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> User();<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>arrow-function</title>
    <link href="/2021/09/28/arrow-function/"/>
    <url>/2021/09/28/arrow-function/</url>
    
    <content type="html"><![CDATA[<h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><ol><li><p>js存在一些在其他地方运行的函数，如<code>arr.forEach(func)</code>和<code>setTimeout(func)</code>。这些情况下我们一般不想离开当前上下文，这时候可以用到箭头函数。</p></li><li><p>箭头函数没有自己的<code>this</code>，如果箭头函数内访问到了<code>this</code>，会从外侧取.<br>如：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> group = &#123;<br>  title: <span class="hljs-string">&quot;Our Group&quot;</span>,<br>  students: [<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;Pete&quot;</span>, <span class="hljs-string">&quot;Alice&quot;</span>],<br><br>  <span class="hljs-function"><span class="hljs-title">showList</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.students.forEach(<br>      student =&gt; alert(<span class="hljs-built_in">this</span>.title + <span class="hljs-string">&#x27;: &#x27;</span> + student)<br>    );<br>  &#125;<br>&#125;;<br>group.showList();<br></code></pre></td></tr></table></figure><p> 箭头函数中的<code>this</code>与外侧<code>showList</code>中的<code>this</code>相同。<br> 与普通函数做比较：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> group = &#123;<br>  title: <span class="hljs-string">&quot;Our Group&quot;</span>,<br>  students: [<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;Pete&quot;</span>, <span class="hljs-string">&quot;Alice&quot;</span>],<br><br>  <span class="hljs-function"><span class="hljs-title">showList</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.students.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">student</span>) </span>&#123;<br>      <span class="hljs-comment">// Error: Cannot read property &#x27;title&#x27; of undefined</span><br>      alert(<span class="hljs-built_in">this</span>.title + <span class="hljs-string">&#x27;: &#x27;</span> + student);<br>    &#125;);<br>  &#125;<br>&#125;;<br><br>group.showList()<br></code></pre></td></tr></table></figure><p> 会报错，因为<code>forEach</code>运行函数时，<code>this</code>默认是<code>undefined</code>(不会影响箭头函数，因为箭头函数根本没有<code>this</code>)</p></li><li><p>箭头函数与<code>bind</code>的细微差别（<code>=&gt;</code> 与 <code>.bind(this)</code>）</p><ul><li><p><code>.bind(this)</code>创建函数的“绑定版本“</p></li><li><p><code>=&gt;</code> 不创建任何绑定：箭头函数只是没有this，对<code>this</code>的查找与正常变量的搜索相同（从外部的词法作用域查找）</p></li></ul></li><li><p>箭头函数没有<code>arguments</code></p><p> 这一点在装饰函数时很有用，因为此时我们需要转发当前函数调用的<code>this</code>和<code>arguments</code>。如：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defer</span>(<span class="hljs-params">f, ms</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> f.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>), ms);<br>  &#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params">who</span>) </span>&#123;<br>  alert(<span class="hljs-string">&#x27;Hello, &#x27;</span> + who);<br>&#125;<br><br><span class="hljs-keyword">let</span> sayHiDeferred = defer(sayHi, <span class="hljs-number">2000</span>);<br>sayHiDeferred(<span class="hljs-string">&quot;John&quot;</span>); <span class="hljs-comment">// Hello, John after 2 seconds</span><br></code></pre></td></tr></table></figure><p> 如果不用箭头函数来写的话，<code>defer</code>函数是这样的：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defer</span>(<span class="hljs-params">f, ms</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> ctx = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-keyword">return</span> f.apply(ctx, args);<br>    &#125;, ms);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>有趣的小tricks</title>
    <link href="/2021/07/15/%E6%9C%89%E8%B6%A3%E7%9A%84%E5%B0%8Ftricks/"/>
    <url>/2021/07/15/%E6%9C%89%E8%B6%A3%E7%9A%84%E5%B0%8Ftricks/</url>
    
    <content type="html"><![CDATA[<ol><li><a href="https://stackoverflow.com/a/53336754/6028514">利用<code>css3 filter</code>改变svg的颜色</a>：有时候ui会要求图标hover变色，但是图标是以<code>&lt;img src=&quot;xxx.svg&quot;&gt;</code>的形式引入的（因此不能通过设置<code>color</code>来改变颜色），也不想或者不能使用两张图片，此时就可以用css3 的filter设置颜色。</li><li><a href="https://stackoverflow.com/questions/1106377/detect-when-browser-receives-file-download">巧妙得知浏览器是否开始下载文件</a>：下载文件时，接口比较慢，想显示loading，但不知道是否开始下载怎么办？前端在请求下载文件时，向后端传递一个随机的<code>downloadToken</code>，后端返回文件流的header里面<code>set-cookie``downloadToken</code>( <strong>注意<code>cookie</code>的<code>path</code></strong> ，对于单页面应用，且<code>history</code>模式为<code>hash</code>，建议<code>path</code>设置为<code>/</code>)，前端轮询本地的<code>cookie</code>，发现<code>cookie</code>中的<code>dnloadToken</code>与发送给后端的<code>dnloadToken</code>相同时，则说明浏览器已开始下载。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>javascript.info读书笔记 -- Prototype篇</title>
    <link href="/2021/05/12/javascript-info/"/>
    <url>/2021/05/12/javascript-info/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文记录自己在学习时的一些<code>notable points</code>。一是为了在读书的时候，对每一小节进行总结，加深印象，提高学习效果，避免“看完即忘”；二是为了在之后回顾的时候，可以迅速地“取精华而废糟粕”，避免把大量的时间浪费在人尽皆知的简单知识上。</p></blockquote><h1 id="Prototypes-inheritance"><a href="#Prototypes-inheritance" class="headerlink" title="Prototypes, inheritance"></a>Prototypes, inheritance</h1><p><a href="https://javascript.info/prototype-inheritance">文章地址</a></p><h2 id="Prototypal-inheritance"><a href="#Prototypal-inheritance" class="headerlink" title="Prototypal inheritance"></a>Prototypal inheritance</h2><h3 id="Prototype"><a href="#Prototype" class="headerlink" title="[[Prototype]]"></a>[[Prototype]]</h3><ol><li>the references can’t go in circles. JavaScript will throw an error if we try to assign <strong>proto</strong> in a circle.</li><li>The value of <strong>proto</strong> can be either an object or null. Other types are ignored.</li><li><code>__proto__</code>是内部的<code>[[Prototype]]</code>的getter/setter，并不完全等同于<code>[[Prototype]]</code>。现代的JavaScript建议我们使用<code>Object.getPrototypeOf/Object.setPrototypeOf</code>来获取/设置原型。</li></ol><h3 id="Writing-doesn’t-use-prototype"><a href="#Writing-doesn’t-use-prototype" class="headerlink" title="Writing doesn’t use prototype"></a>Writing doesn’t use prototype</h3><ol><li>只有在读取属性时才会从原型链上找，赋值/删除操作直接在对象本身上进行。<strong>注意！</strong>访问属性(Accessor properties)是例外，因为赋值是由setter函数处理的。如：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> user = &#123;<br>  name: <span class="hljs-string">&quot;John&quot;</span>,<br>  surname: <span class="hljs-string">&quot;Smith&quot;</span>,<br><br>  <span class="hljs-keyword">set</span> <span class="hljs-title">fullName</span>(<span class="hljs-params">value</span>) &#123;<br>    [<span class="hljs-built_in">this</span>.name, <span class="hljs-built_in">this</span>.surname] = value.split(<span class="hljs-string">&quot; &quot;</span>);<br>  &#125;,<br><br>  <span class="hljs-keyword">get</span> <span class="hljs-title">fullName</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span> <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.surname&#125;</span>`</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">let</span> admin = &#123;<br>  __proto__: user,<br>  isAdmin: <span class="hljs-literal">true</span><br>&#125;;<br><br>alert(admin.fullName); <span class="hljs-comment">// John Smith (*)</span><br><br><span class="hljs-comment">// setter triggers!</span><br>admin.fullName = <span class="hljs-string">&quot;Alice Cooper&quot;</span>; <span class="hljs-comment">// (**)</span><br><br>alert(admin.fullName); <span class="hljs-comment">// Alice Cooper, state of admin modified</span><br>alert(user.fullName); <span class="hljs-comment">// John Smith, state of user protected</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="for…in-loop"><a href="#for…in-loop" class="headerlink" title="for…in loop"></a>for…in loop</h3><ol><li>The for..in loop iterates over inherited properties too.</li><li>Almost all other key/value-getting methods, such as Object.keys, Object.values and so on ignore inherited properties.</li></ol><p>这一节课后习题<code>Why are both hamsters full</code>可以看下</p><h2 id="F-prototype"><a href="#F-prototype" class="headerlink" title="F.prototype"></a>F.prototype</h2><ol><li><code>F.prototype</code> property is only used when <code>new F</code> is called, it assigns <code>[[Prototype]]</code> of the new object. 如果在创建一个对象后，改变<code>F.prototype</code>，则只会影响下一次用<code>new F</code>创建的对象的<code>[[Prototype]]</code>，已创建的对象的<code>[[Prototype]]</code>则不受影响。</li></ol><h3 id="Default-F-prototype-constructor-property"><a href="#Default-F-prototype-constructor-property" class="headerlink" title="Default F.prototype, constructor property"></a>Default F.prototype, constructor property</h3><ol><li><p>Every function has the <code>&quot;prototype&quot;</code> property even if we don’t supply it.<br>The default <code>&quot;prototype&quot;</code> is an object with the only property <code>constructor</code> that points back to the function itself.<br>即，每个函数都默认有<code>prototype</code>属性，它是<code>&#123;constructor: function itself&#125;</code>，如下图所示。<br><img src="prototype/function-prototype-constructor.svg" alt="函数默认原型"></p></li><li><p>设<code>Rabbit</code>为构造函数，<code>rabbit</code>为<code>Rabbit</code>的实例，则<code>rabbit</code>可<strong>通过原型链</strong>访问到它的构造函数，如下图所示。即<code>rabbit</code>的<code>constructor</code>是从原型链上获取的。<br><img src="prototype/rabbit-prototype-constructor.svg" alt="实例访问构造函数"><br>需要注意的是，JavaScript itself does not ensure the right <code>&quot;constructor&quot;</code> value.</p></li></ol><p>这一节的两道课后习题都可看下</p><h2 id="Native-prototypes"><a href="#Native-prototypes" class="headerlink" title="Native prototypes"></a>Native prototypes</h2><p><img src="prototype/native-prototypes-classes.svg" alt="All of the built-in prototypes have Object.prototype on the top"></p><h3 id="Primitives"><a href="#Primitives" class="headerlink" title="Primitives"></a>Primitives</h3><p>The most intricate thing happens with strings, numbers and booleans.</p><p>As we remember, they are not objects. But if we try to access their properties, temporary wrapper objects are created using built-in constructors String, Number and Boolean. They provide the methods and disappear.</p><p>These objects are created invisibly to us and most engines optimize them out, but the specification describes it exactly this way. Methods of these objects also reside in prototypes, available as String.prototype, Number.prototype and Boolean.prototype.</p><p>课后习题<code>Add the decorating &quot;defer()&quot; to functions</code>中关于<code>apply</code>的可以看看。</p><h2 id="Prototype-methods-objects-without-proto"><a href="#Prototype-methods-objects-without-proto" class="headerlink" title="Prototype methods, objects without proto"></a>Prototype methods, objects without <strong>proto</strong></h2><p><code>__proto__</code>属性在浏览器端略微过时了。以下有三个现代的方法来替代它：</p><ol><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create">Object.create(proto, [descriptors])</a> – creates an empty object with given proto as [[Prototype]] and optional property descriptors.</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf">Object.getPrototypeOf(obj)</a> – returns the [[Prototype]] of obj.</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf">Object.setPrototypeOf(obj, proto)</a> – sets the [[Prototype]] of obj to proto.</li></ol><p>通过<code>Object.create</code>的第二个参数（属性描述符），可以实现更加精确的属性拷贝：</p><blockquote><p>We can use Object.create to perform an object cloning more powerful than copying properties in for..in:</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> clone = <span class="hljs-built_in">Object</span>.create(<span class="hljs-built_in">Object</span>.getPrototypeOf(obj), <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(obj));<br></code></pre></td></tr></table></figure><blockquote><p>This call makes a truly exact copy of obj, including all properties: enumerable and non-enumerable, data properties and setters/getters – everything, and with the right [[Prototype]].</p></blockquote><h3 id="Brief-history"><a href="#Brief-history" class="headerlink" title="Brief history"></a>Brief history</h3><blockquote><p>Don’t change [[Prototype]] on existing objects if speed matters<br>Javascript引擎对于作用域链的查找做了优化，因此，如果在运行时(原文为<code>on the fly</code>)通过<code>Object.setPrototypeOf</code>或<code>obj.__proto__=</code>更改了原型，就会破坏这种优化，从而影响运行速度。</p></blockquote><h3 id="“Very-plain”-objects"><a href="#“Very-plain”-objects" class="headerlink" title="“Very plain” objects"></a>“Very plain” objects</h3><p>对对象进行赋值时，有一个有趣的现象：对<code>__proto__</code>的赋值有时会不生效。</p><blockquote><p>That shouldn’t surprise us. The <strong>proto</strong> property is special: it must be either an object or null. A string can not become a prototype.<br>解决方法有：</p></blockquote><ol><li>使用<code>Map</code> instead of <code>plain objects</code></li><li>使用<code>Object.create(null)</code></li></ol><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>Other methods:</p><ol><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys">Object.keys(obj)</a> / <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values">Object.values(obj)</a> / <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries">Object.entries(obj)</a> – returns an array of enumerable own string property names/values/key-value pairs.</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols">Object.getOwnPropertySymbols(obj)</a> – returns an array of all own symbolic keys.</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames">Object.getOwnPropertyNames(obj)</a> – returns an array of all own string keys.</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys">Reflect.ownKeys(obj)</a> – returns an array of all own keys. 等于<code>Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))</code></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty">obj.hasOwnProperty(key)</a>: returns true if obj has its own (not inherited) key named key.</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>javascript.info读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Array.isArray vs instanceof</title>
    <link href="/2021/05/10/array/"/>
    <url>/2021/05/10/array/</url>
    
    <content type="html"><![CDATA[<h2 id="先说结论"><a href="#先说结论" class="headerlink" title="先说结论"></a>先说结论</h2><p><code>Array.isArray</code>优于<code>instance of Array</code>。</p><p><code>Array.isArray</code>是<code>ES5</code>的方法： <code>MDN文档</code>：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray">MDN Array.isArray</a><br><code>MDN</code>上提到：</p><blockquote><p>When checking for Array instance, Array.isArray is preferred over instanceof because it works through iframes.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> iframe = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;iframe&#x27;</span>);<br><span class="hljs-built_in">document</span>.body.appendChild(iframe);<br>xArray = <span class="hljs-built_in">window</span>.frames[<span class="hljs-built_in">window</span>.frames.length - <span class="hljs-number">1</span>].Array;<br><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> xArray(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// [1,2,3]</span><br><br><span class="hljs-comment">// Correctly checking for Array</span><br><span class="hljs-built_in">Array</span>.isArray(arr);  <span class="hljs-comment">// true</span><br><span class="hljs-comment">// Considered harmful, because doesn&#x27;t work through iframes</span><br>arr <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>; <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>可以看到，在当前页面新创建一个<code>iframe</code>，用<code>iframe</code>中的<code>Array</code>构造函数<code>new</code>一个数组<code>xArray</code>，<code>Array.isArray</code>可以<strong>在当前页面</strong>判断出<code>xArray</code>是一个数组，而<code>instanceof</code>不可以。</p><p>因此<code>Array.isArray</code>优于<code>instance of Array</code>。</p><h2 id="深入一点"><a href="#深入一点" class="headerlink" title="深入一点"></a>深入一点</h2><h3 id="多个global"><a href="#多个global" class="headerlink" title="多个global"></a>多个<code>global</code></h3><blockquote><p>A global object is an object that always exists in the global scope.</p></blockquote><p>根据<a href="https://developer.mozilla.org/en-US/docs/Glossary/Global_object">MDN Global object</a>，各个脚本执行上下文有各自的<code>global</code>。浏览器中的<code>window</code>、<code>Node.js</code>中的<code>global</code>都是各自运行环境中的<code>global</code>。</p><p>而浏览器中，各个窗口/<code>iframe</code>，并不共享同一个<code>window</code>。而在不同的<code>window</code>中，<code>Array.prototype</code>也是不同的（若是相同的，则恶意网页修改<code>Array.prototype</code>会引起严重后果）。因此<code>instanceof Array</code>在跨页面/<code>iframe</code>的情况下不适用。</p><h3 id="其他的检测数组的方法"><a href="#其他的检测数组的方法" class="headerlink" title="其他的检测数组的方法"></a>其他的检测数组的方法</h3><p>a.constructor === Array<br>这个方法与<code>instanceof Array</code>类似。<code>a instanceof Array</code>会在<code>a</code>的原型链上向上寻找<code>Array.protype</code>，而若<code>a</code>为数组，则<code>a.__proto__ === a.constructor.prototype === Array.prototype</code>，所以二者类似。</p><p>其他的方法来自<a href="http://web.mit.edu/jwalden/www/isArray.html">这里</a>，作者用了一个有意思的比喻来描述这些方法“叫得像鸭子它就是一个鸭子”。</p><blockquote><p> Another option relies on so-called “duck typing”, where if a value quackslooks like a duckan array then it is a duckan array.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Array</span>.isArray(&#123; <span class="hljs-attr">constructor</span>: <span class="hljs-built_in">Array</span> &#125;) <span class="hljs-comment">// 通过a.constructor === Array 判断</span><br><span class="hljs-built_in">Array</span>.isArray(&#123; <span class="hljs-attr">push</span>: <span class="hljs-built_in">Array</span>.prototype.push, <span class="hljs-attr">concat</span>: <span class="hljs-built_in">Array</span>.prototype.concat &#125;) <span class="hljs-comment">// 通过判断对象是否有数组的方法判断</span><br><span class="hljs-built_in">Object</span>.prototype.toString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[object Array]&quot;</span>; &#125;;  <span class="hljs-comment">// 通过a.toString() === &quot;[object Array]&quot; 判断</span><br><span class="hljs-built_in">Array</span>.isArray(&#123; <span class="hljs-attr">__proto__</span>: <span class="hljs-built_in">Array</span>.prototype &#125;) <span class="hljs-comment">// 通过a.__proto__ === Array.prototype判断</span><br><span class="hljs-built_in">Array</span>.isArray(&#123; <span class="hljs-attr">length</span>: <span class="hljs-number">0</span> &#125;)  <span class="hljs-comment">// 通过是否有length属性判断</span><br></code></pre></td></tr></table></figure><p>在此不再赘述。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>移动端兼容</title>
    <link href="/2021/04/28/mobile-compatibility/"/>
    <url>/2021/04/28/mobile-compatibility/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近作者在开发移动端会议室系统的过程中，备受跨设备兼容的困扰。前车之鉴，后人之师，在此我把遇到、解决过的兼容性问题列举出来，一是为了做个记录，二也是给大家提供参考。</p><h3 id="iOS上底部安全区的适配"><a href="#iOS上底部安全区的适配" class="headerlink" title="iOS上底部安全区的适配"></a>iOS上底部安全区的适配</h3><p>iOS取消实体home键，改为全面屏手势后，在屏幕底部展示了一个小黑条，而如果写网页的时候不加处理，内容就会被小黑条覆盖掉。解决方法如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  // 底部安全区适配<br>  <span class="hljs-attribute">padding-bottom</span>: <span class="hljs-built_in">constant</span>(safe-area-inset-bottom); // iOS老版本写法，为了保持向前兼容，也要加上，且要放到前面<br>  <span class="hljs-attribute">padding-bottom</span>: <span class="hljs-built_in">env</span>(safe-area-inset-bottom);<br>&#125;<br></code></pre></td></tr></table></figure><p>将以上样式应用于页面外部容器/<strong>定位为fixed且bootom为0（即固定在页面底部显示）的元素</strong>即可。<br>对于安卓机型，作者测试了一下小米10 pro，该机型在开启底部小黑条时，是在屏幕最下方单独为小黑条保留了一部分空间，没有侵入app，所以无需额外设置。</p><h3 id="IOS企业微信端对于fixed元素位置显示错误"><a href="#IOS企业微信端对于fixed元素位置显示错误" class="headerlink" title="IOS企业微信端对于fixed元素位置显示错误"></a>IOS企业微信端对于fixed元素位置显示错误</h3><p>如下两图所示。其中左图为有问题的页面，右图为正常页面。</p><figure><img src="fixed-bug.png" width="49%"><img src="fixed-normal.png" width="49%"></figure><p>bug原因猜测：</p><center><img src="fixed-reason.png" width="49%"></center>如图所示，页面最外层容器没有铺满当前页。将最外层容器高度铺满页面后，bug被修复：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#app</span> &#123;<br>  <span class="hljs-attribute">min-height</span>: <span class="hljs-number">100vh</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="height-100vh的问题"><a href="#height-100vh的问题" class="headerlink" title="height: 100vh的问题"></a>height: 100vh的问题</h3><p>在移动端使用100vh可能会出现双重滚动条/底部fixed元素被盖住。拿移动端的chrome举例，浏览器把地址栏也算入到了可视高度内（下滑地址栏可隐藏），因此当展示地址栏的时候，100vh就要比实际的可视高度要高，因此会出现双重滚动条/底部fixed元素被盖住。</p><center><img src="mobile-chrome.jpeg" width="49%"></center><p>解决方法是：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">min-height</span>: <span class="hljs-number">100vh</span>;<br>  <span class="hljs-attribute">min-height</span>: -webkit-fill-available;<br>&#125;<br><span class="hljs-selector-tag">html</span> &#123;<br>  <span class="hljs-attribute">height</span>: -webkit-fill-available;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考资料：<a href="https://css-tricks.com/css-fix-for-100vh-in-mobile-webkit/">CSS fix for 100vh in mobile WebKit</a></p><h3 id="大分辨率图片加载不出来的问题"><a href="#大分辨率图片加载不出来的问题" class="headerlink" title="大分辨率图片加载不出来的问题"></a>大分辨率图片加载不出来的问题</h3><blockquote><p>仅安卓端企业微信内置浏览器有问题</p></blockquote><p>经过测试，7088*10630分辨率的图片，安卓端企业微信内置浏览器无法加载出（合理推测大分辨率的加载不出）<br>解决方法是在上传图片的时候制定图片的最大分辨率，超过分辨率则用canvas降分辨率</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resizeImg</span> (<span class="hljs-params">file</span>) </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getBase64</span>(<span class="hljs-params">file</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> reader = <span class="hljs-keyword">new</span> FileReader()<br>      reader.readAsDataURL(file)<br>      reader.onload = <span class="hljs-function">() =&gt;</span> resolve(reader.result)<br>      reader.onerror = <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> reject(error)<br>    &#125;)<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getImg</span>(<span class="hljs-params">src</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> img = <span class="hljs-keyword">new</span> Image()<br>      img.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        resolve(img)<br>      &#125;<br>      img.src = src<br>    &#125;)<br>  &#125;<br>    <br>  <span class="hljs-keyword">const</span> canvas = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;canvas&#x27;</span>)<br>  <span class="hljs-keyword">const</span> src = <span class="hljs-keyword">await</span> getBase64(file)<br>  <span class="hljs-keyword">const</span> img = <span class="hljs-keyword">await</span> getImg(src)<br><br>  <span class="hljs-comment">// 缩放</span><br>  <span class="hljs-comment">// 限制最大x分辨率</span><br>  <span class="hljs-keyword">const</span> x = <span class="hljs-number">1600</span><br>  <span class="hljs-keyword">let</span> width = img.width<br>  <span class="hljs-keyword">let</span> height = img.height<br>  <span class="hljs-keyword">if</span> (width &gt; x) &#123;<br>    height *= x / width<br>    width = x<br>  &#125;<br><br>  <span class="hljs-comment">// 绘画</span><br>  canvas.width = width<br>  canvas.height = height<br>  <span class="hljs-keyword">const</span> ctx = canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>)<br>  ctx.drawImage(img, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height)<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 转为为提交所需格式</span><br>    canvas.toBlob(<span class="hljs-function">(<span class="hljs-params">blob</span>) =&gt;</span> &#123;<br>      resolve(blob)<br>    &#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>提交上传图片时，在formData里append处理后的图片即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> form = <span class="hljs-keyword">new</span> FormData()<br><span class="hljs-keyword">const</span> blob = <span class="hljs-keyword">await</span> resizeImg(file)<br>form.append(<span class="hljs-string">&#x27;file&#x27;</span>, blob)<br></code></pre></td></tr></table></figure><h3 id="安卓端文字偏上，某些机型尤其明显（使用flex垂直居中时）"><a href="#安卓端文字偏上，某些机型尤其明显（使用flex垂直居中时）" class="headerlink" title="安卓端文字偏上，某些机型尤其明显（使用flex垂直居中时）"></a>安卓端文字偏上，某些机型尤其明显（使用flex垂直居中时）</h3><p>！不知道咋解决，有人知道的话私信我一下谢谢～（叹气）</p><h3 id="不同逻辑分辨率的设备兼容"><a href="#不同逻辑分辨率的设备兼容" class="headerlink" title="不同逻辑分辨率的设备兼容"></a>不同逻辑分辨率的设备兼容</h3><p>鉴于现在主流浏览器对于viewport 单位 (vw, vh, vmin, vmax)支持良好，因此在对于不同逻辑分辨率的设备，可以使用<code>postcss-px-to-viewport</code>插件，来将<code>px</code>单位改成<code>vw</code>单位。<br>需要注意的是: </p><ol><li><code>postcss-px-to-viewport</code>这个插件<code>npm</code>源与<code>github</code>源不一致，<code>npm</code>源会导致一些选项，如<code>include</code>选项无效，而由于<a href="https://github.com/npm/cli/issues/624">npm的bug</a>，在<code>docker</code>中用<code>npm</code>安装<code>github</code>源的文件会失败，从而导致自动部署失败。<br>参考资料：<a href="https://vant-contrib.gitee.io/vant/#/zh-CN/advanced-usage#viewport-bu-ju">vant 浏览器适配</a></li><li>经过<code>px</code>到<code>vw</code>的转换后，对于小数点像素（如<code>1.3456px</code>），不同的浏览器有不同的处理策略，可能会导致使用同样样式的线条，有的粗有的细的问题</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【TSD】Garden招聘系统版本检测实现总结</title>
    <link href="/2021/03/04/version-detect/"/>
    <url>/2021/03/04/version-detect/</url>
    
    <content type="html"><![CDATA[<h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><p>Garden前端在Q2上线了新版本检测功能，以下是对该实现方法的说明，和由此延伸出的其他思考。</p><h2 id="背景和目的"><a href="#背景和目的" class="headerlink" title="背景和目的"></a>背景和目的</h2><ol><li>Garden招聘系统迭代迅速，基本上每周都有上线，版本变动频繁。</li><li>频繁使用Garden的业务方，在打开Garden后，不会去频繁刷新</li><li>对于单页面应用，不刷新则无法获取最新版本</li></ol><p>以上就会导致，业务方有可能在过时的版本上操作，可能会产生报错，增加产品答疑的工作量，也有可能产生脏数据。<br>针对以上问题，Garden组开发了新版本检测功能。</p><h2 id="技术和方案介绍"><a href="#技术和方案介绍" class="headerlink" title="技术和方案介绍"></a>技术和方案介绍</h2><h3 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h3><p><img src="%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B.jpg" alt="整体流程"><br>项目中代码变动后，webpack打包时的<code>contenthash</code>也会变动（<code>hash</code>、<code>chunkHash</code>、<code>contentHash</code>之间的区别参考<a href="https://stackoverflow.com/a/52786672">这里</a>)。因此如果我们在一个全局的组件中定时请求<code>index.html</code>，再从<code>app.[hash].js</code>中将hash解析出来，与当前页<code>index.html</code>中的hash做对比，若hash不同，则版本发生了变动</p><h3 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs javascript">  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">compareHash</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.notificationShown) <span class="hljs-keyword">return</span><br><br>    <span class="hljs-keyword">const</span> latestHash = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.getLatestHash()<br>    <span class="hljs-keyword">const</span> currentHash = <span class="hljs-built_in">this</span>.getCurrentHash()<br><br>    <span class="hljs-keyword">if</span> (latestHash !== currentHash) &#123;<br>      <span class="hljs-built_in">this</span>.notificationShown = <span class="hljs-literal">true</span><br>      <span class="hljs-comment">// 在这里发送通知</span><br>      &#125;)<br>    &#125;<br>  &#125;,<br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">getLatestHash</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> axios.get(<br>      <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">window</span>.location.protocol&#125;</span>//<span class="hljs-subst">$&#123;<span class="hljs-built_in">window</span>.location.host&#125;</span>/`</span>,<br>      &#123;<br>        headers: &#123;<br>          <span class="hljs-string">&#x27;Cache-Control&#x27;</span>: <span class="hljs-string">&#x27;max-age=0&#x27;</span>,<br>        &#125;,<br>      &#125;,<br>    )<br><br>    <span class="hljs-comment">// 构建html</span><br>    <span class="hljs-keyword">let</span> el = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;html&#x27;</span>)<br>    el.innerHTML = response.data<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getHashFromHtml(el)<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-title">getCurrentHash</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getHashFromHtml(<span class="hljs-built_in">document</span>)<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-title">getHashFromHtml</span>(<span class="hljs-params">el</span>)</span> &#123;<br>    <span class="hljs-comment">// 获取js script的src</span><br>    <span class="hljs-keyword">let</span> scriptTags = el.getElementsByTagName(<span class="hljs-string">&#x27;script&#x27;</span>)<br>    <span class="hljs-keyword">let</span> scriptSrcs = <span class="hljs-built_in">Array</span>.prototype.map.call(scriptTags, <span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.src)<br><br>    <span class="hljs-comment">// 正则获取app.[hash].js的hash</span><br>    <span class="hljs-comment">// 默认hashDigest为hex，即app.js的hash为16进制</span><br>    <span class="hljs-comment">// 用vue inspect --mode production查看webpack配置</span><br>    <span class="hljs-comment">// filename与chunkFilename都是&#x27;js/[name].[contenthash:8].js&#x27;</span><br>    <span class="hljs-keyword">let</span> appHashRegex = <span class="hljs-regexp">/.*app\.(?&lt;hash&gt;[0-9a-f]&#123;8&#125;)\.js/</span><br>    <span class="hljs-keyword">return</span> scriptSrcs<br>      .map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.match(appHashRegex))<br>      .filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item)[<span class="hljs-number">0</span>].groups.hash<br>  &#125;,<br>&#125;,<br><br></code></pre></td></tr></table></figure><h2 id="其他思考"><a href="#其他思考" class="headerlink" title="其他思考"></a>其他思考</h2><h3 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h3><p>若index.html没有变化，浏览器向后端请求时，会返回304 Not Modified，那能不能根据axios返回的response的状态码来判断版本有没有更新呢？下面给出作者的探究思路。</p><ol><li><p>尝试将axios的response打印出来，却发现当Chrome network panel显示结果为304时，console打印出的状态码为200。但是为什么呢？</p></li><li><p>原因是，axios请求头中没有<code>cache validator</code>（缓存验证），如<code>If-Modified-Since</code>(<code>Last-Modified</code>)或者<code>If-None-Match</code>(<code>Etag</code>)，因此Chrome不会给axios返回200.</p></li><li><p>根据<code>HTTP/1.1 cache</code>的规范，<a href="https://datatracker.ietf.org/doc/html/rfc7234#section-4.3.2">Handling a Received Validation Request</a>，</p><blockquote><p>When a cache decides to revalidate its own stored responses for a request that contains an If-None-Match list of entity-tags, the cache MAY combine the received list with a list of  entity-tags from its own stored set of responses (fresh or stale) and send the union of the two lists as a replacement If-None-Match header field value in the forwarded request.</p></blockquote><p> 可以理解为：对于同一个资源A，clientA缓存了一份，clientB也缓存了一份，且请求转发顺序为clientA-&gt;clientB-&gt;服务器，则cliendA发送请求验证缓存时（使用<code>If-None-Match</code>），clientB也可以把自己缓存的资源的<code>Etag</code>加入到  <code>If-None-Match</code>列表中。</p><blockquote><p>If the response to the forwarded request is 304 (Not Modified) and has an ETag header field value with an entity-tag that is not in the client’s list, the cache MUST generate a 200(OK)  response for the client by reusing its corresponding stored response, as updated by the 304 response metadata (Section 4.3.4).</p></blockquote><p> 大概意思可以理解为：服务器给clientB返回了304(<code>response</code>头中有<code>Etag</code>)，但是clienA请求头中的<code>If-None-Match</code>与服务器返回的<code>Etag</code>不相同（因为，如上文所说，clientB将自己具有但是clientA不具有的缓存的<code>Etag</code>加入到了<code>If-None-Match</code>中），则clientB会给clientA返回200 Ok(<code>response</code>是clienA缓存的正确的文件，并经过服务器返回的<code>response</code>中的metadata更新)<br> 以上应该可以让大家更好地理解第二点。（axios中没有存储正确的缓存文件，因此即使chrome收到了304的返回，依然要告诉axios这是200 ok）</p></li><li><p>对于<code>Last-Modified</code>验证字段，则不存在(3)中所说的，因为仅凭修改时间，clientB无法判断clientA是否有正确的缓存文件。</p></li><li><p>其他参考：<br> Stackoverflow的<a href="https://stackoverflow.com/a/16817752/6028514">这篇回答</a>，如下：<img src="so_200.png"><br> （回答中提到的<a href="https://www.w3.org/TR/2014/WD-XMLHttpRequest-20140130/">spec</a>提示文档已经过时，如果小伙伴们发现了更加及时、权威的文章，欢迎补充。）<br> 意思大概是，即使服务器返回了<code>304 Not Modified</code>，xhr返回结果中的status仍会是200，除非在请求头中自定义了缓存的验证，即：xhr请求头中自定义<code>If-None-Match</code>或    <code>If-Modified-Since</code>头。但是加了这两个头之后，对于<code>If-None-Match</code>，xhr请求头的<code>If-None-Match</code>必须要和服务器返回的<code>Etag</code>一致，xhr返回结果中的status才会是304。</p></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><p><a href="https://webpack.js.org/configuration/optimization/#optimizationrealcontenthash">realContentHash</a></p></li><li><p>用<code>vue inspect --mode production</code>（也可用<code>npx vue-cli-service inspect --mode production</code>）打印出webpack配置，有以下关注点： </p><ol><li><p><code>output</code>中的<code>filename</code>、<code>chunkFilename</code>，其中<code>chunkFileName</code>是指未被列在<code>entry</code>中，却又需要被打包出的<code>chunk</code>文件的名称。一般来说指懒加载的依赖。<a href="https://mp.weixin.qq.com/s/BHSihethgh_zH0K1J3qwnA">参考地址</a><br>如果这两项的内容是<code>js/[name].[contenthash:8].js</code>，（格式参考<a href="https://webpack.js.org/loaders/file-loader/#placeholders">这里</a>）则可以直接用作者写的正则，否则可能需要编辑配置/重新写正则</p></li><li><p><code>entry</code>项。entry的配置项命名规则，引用官网说明如下：</p><blockquote><p>If a string or array of strings is passed, the chunk is named main. If an object is passed, each key is the name of a chunk, and the value describes the entry point for the chunk.</p></blockquote><p> 我们这里着重看下entry中传入的是否是对象&amp;对象的key（即生成的chunk的name）是否为<code>app</code>，若不是，则需要重新写正则</p></li></ol></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>为macOS bigsur开启HiDpi</title>
    <link href="/2020/11/23/bigSur-hidpi/"/>
    <url>/2020/11/23/bigSur-hidpi/</url>
    
    <content type="html"><![CDATA[<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol><li><a href="https://sspai.com/post/57549">为 macOS 10.15 开启 HiDPI，让 2K 显示器更舒适</a></li><li><a href="https://comsysto.github.io/Display-Override-PropertyList-File-Parser-and-Generator-with-HiDPI-Support-For-Scaled-Resolutions/">SCALED RESOLUTIONS<br>for your MacBooks external Monitor</a></li><li><a href="https://apple.stackexchange.com/a/395509">Mount root as writable in Big Sur</a></li></ol><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文适合有一定基础的人～最好有一定的英语阅读能力&amp;基本的shell知识</p><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><p>先按参考文档1的步骤，进行到<code>复制 plist 配置文件到系统配置目录</code>这一步时，就走不通了，因为在Big Sur中，苹果对于权限要求更严格，要通过额外的一系列操作才能获取根目录的写入权限了（参看文档3）。</p><p>大概解释一下文档3的意思：</p><ol><li>在恢复模式终端运行<code>csrutil authenticated-root disable</code>(与文档1中<code>csrutil disable</code>方法类似)</li><li>重启回系统，终端运行<code>mount</code>，如图所示<img src="./mount.png" alt="mount"><br>则<code>DISK_PATH</code>为<code>/dev/disk1s1</code>（把最后的s+数字去掉）</li><li>随便创建一个挂载的目录，文中路径为<code>~/mount</code>，即为<code>MOUNT_PATH</code></li><li>运行<code>sudo mount -o nobrowse -t apfs DISK_PATH MOUNT_PATH</code>（用上文的变量替换）</li><li>现在就可以在<code>~/mount</code>下修改系统文件了，如：要修改<code>/temp/1.txt</code>的文件，则应修改<code>~/mount/temp/1.txt</code></li><li>修改完成之后，运行<code>sudo bless --folder MOUNT_PATH/System/Library/CoreServices --bootefi --create-snapshot</code>（注意替换路径）</li><li>重启，修改即生效。下面就可以愉快地打开rdm修改分辨率了～</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
